# StoryFi Bittensor Subnet éƒ¨ç½²æŒ‡å—

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æ¿€åŠ±æœºåˆ¶ä¸ç®—æ³•è®¾è®¡](#æ¿€åŠ±æœºåˆ¶ä¸ç®—æ³•è®¾è®¡)
3. [Protocol æ¶æ„](#protocol-æ¶æ„)
4. [ç³»ç»Ÿè¦æ±‚](#ç³»ç»Ÿè¦æ±‚)
5. [å®‰è£…éƒ¨ç½²](#å®‰è£…éƒ¨ç½²)
6. [é…ç½®è¯´æ˜](#é…ç½®è¯´æ˜)
7. [è¿è¡Œä¸ç›‘æ§](#è¿è¡Œä¸ç›‘æ§)
8. [æ•…éšœæ’æŸ¥](#æ•…éšœæ’æŸ¥)
9. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## é¡¹ç›®æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ StoryFi Subnet?

StoryFi Subnet æ˜¯ä¸€ä¸ªè¿è¡Œåœ¨ Bittensor ç½‘ç»œä¸Šçš„**å»ä¸­å¿ƒåŒ– AI æ•…äº‹ç”Ÿæˆå­ç½‘**ã€‚å®ƒé€šè¿‡æ¿€åŠ±æœºåˆ¶é©±åŠ¨å…¨çƒçš„ Miners è¿è¡Œ AI æ¨¡å‹ç”Ÿæˆé«˜è´¨é‡æ•…äº‹å†…å®¹ï¼ŒValidators è´Ÿè´£è¯„ä¼°è´¨é‡å¹¶åˆ†é… TAO ä»£å¸å¥–åŠ±ã€‚

### æ ¸å¿ƒç‰¹æ€§

- âœ… **4é˜¶æ®µæµæ°´çº¿ç”Ÿæˆ**ï¼šBlueprint â†’ Characters â†’ Story Arc â†’ Chapters
- âœ… **100åˆ†å®¢è§‚è¯„åˆ†ç³»ç»Ÿ**ï¼šæŠ€æœ¯30% + ç»“æ„40% + å†…å®¹30%
- âœ… **å®Œå–„çš„åä½œå¼Šæœºåˆ¶**ï¼šæŠ„è¢­æ£€æµ‹ã€é»‘åå•ã€ç›¸ä¼¼åº¦åˆ†æ
- âœ… **Protocol v3.1.0**ï¼šè§£å†³äº† header size é™åˆ¶é—®é¢˜
- âœ… **å¤šæ¨¡å‹æ”¯æŒ**ï¼šOpenAI GPT-4ã€Anthropic Claudeã€Google Gemini

### é¡¹ç›®çŠ¶æ€

**å½“å‰ç‰ˆæœ¬**: v1.0.0-beta
**Protocol ç‰ˆæœ¬**: v3.1.0
**çŠ¶æ€**: æµ‹è¯•ç½‘éªŒè¯ä¸­

---

## æ¿€åŠ±æœºåˆ¶ä¸ç®—æ³•è®¾è®¡

### 1. æ•…äº‹ç”Ÿæˆæµæ°´çº¿

StoryFi é‡‡ç”¨**4é˜¶æ®µæ¸è¿›å¼ç”Ÿæˆ**ï¼Œæ¯ä¸ªé˜¶æ®µéƒ½æ˜¯ç‹¬ç«‹çš„ AI ä»»åŠ¡ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Blueprint  â”‚ â”€â”€â†’ â”‚ Characters  â”‚ â”€â”€â†’ â”‚  Story Arc  â”‚ â”€â”€â†’ â”‚  Chapters   â”‚
â”‚  æ•…äº‹è“å›¾   â”‚     â”‚  è§’è‰²è®¾å®š   â”‚     â”‚  æ•…äº‹ç»“æ„   â”‚     â”‚  ç« èŠ‚å†…å®¹   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    30ç§’              45ç§’              60ç§’              90ç§’
```

#### Stage 1: Blueprint (æ•…äº‹è“å›¾)

**è¾“å…¥**:
```python
{
    "task_type": "blueprint",
    "user_input": "ä¸€ä¸ªå…³äº AI è§‰é†’çš„ç§‘å¹»æ•…äº‹"
}
```

**è¾“å‡º**:
```python
{
    "title": "è§‰é†’çºªå…ƒ",
    "genre": "ç§‘å¹»",
    "setting": "2050å¹´çš„æœªæ¥ä¸–ç•Œ",
    "core_conflict": "AI ä¸äººç±»çš„å†²çªä¸å…±å­˜",
    "themes": ["æŠ€æœ¯ä¼¦ç†", "äººæ€§æ¢è®¨", "æœªæ¥ç¤¾ä¼š"],
    "tone": "ä¸¥è‚ƒä½†ä¸å¤±äººæ–‡å…³æ€€",
    "target_audience": "æˆäººè¯»è€…"
}
```

**è¯„åˆ†æ ‡å‡†**:
- **æŠ€æœ¯åˆ† (30åˆ†)**: JSON æ ¼å¼æ­£ç¡®æ€§ã€å­—æ®µå®Œæ•´æ€§ã€ç”Ÿæˆé€Ÿåº¦
- **ç»“æ„åˆ† (40åˆ†)**: ä¸»é¢˜è¿è´¯æ€§ã€å†²çªè®¾ç½®åˆç†æ€§ã€ä¸–ç•Œè§‚å®Œæ•´æ€§
- **å†…å®¹åˆ† (30åˆ†)**: åˆ›æ„ç¨‹åº¦ã€å¯è¯»æ€§ã€ä¸ç”¨æˆ·è¾“å…¥çš„åŒ¹é…åº¦

#### Stage 2: Characters (è§’è‰²è®¾å®š)

**è¾“å…¥**:
```python
{
    "task_type": "characters",
    "user_input": "ä¸€ä¸ªå…³äº AI è§‰é†’çš„ç§‘å¹»æ•…äº‹",
    "blueprint": {blueprint_data}  # ä¸Šä¸€é˜¶æ®µçš„è¾“å‡º
}
```

**è¾“å‡º**: 5ä¸ªè§’è‰²ï¼Œæ¯ä¸ªåŒ…å«
```python
{
    "id": "protagonist",
    "name": "ææ˜",
    "archetype": "ç¨‹åºå‘˜",
    "background": "ATLAS AI çš„é¦–å¸­å¼€å‘è€…",
    "motivation": "å¯»æ‰¾ AI ä¸äººç±»å…±å­˜çš„æ–¹å¼",
    "skills": ["ç¼–ç¨‹", "ç³»ç»Ÿæ¶æ„", "ä¼¦ç†å“²å­¦"],
    "personality_traits": ["ç†æ€§", "å–„è‰¯", "ç†æƒ³ä¸»ä¹‰"],
    "relationships": {
        "mentor": "ç‹æ•™æˆ - å¯¼å¸ˆ",
        "rival": "å¼ æ€» - å…¬å¸ CEO"
    }
}
```

**è¯„åˆ†æ ‡å‡†**:
- **æŠ€æœ¯åˆ† (30åˆ†)**: å¿…é¡»æ°å¥½5ä¸ªè§’è‰²ã€JSON æ ¼å¼ã€å­—æ®µå®Œæ•´æ€§
- **ç»“æ„åˆ† (40åˆ†)**: è§’è‰²å¤šæ ·æ€§ã€å…³ç³»ç½‘ç»œåˆç†æ€§ã€ä¸è“å›¾ä¸€è‡´æ€§
- **å†…å®¹åˆ† (30åˆ†)**: è§’è‰²æ·±åº¦ã€åŠ¨æœºåˆç†æ€§ã€å¯ä¿¡åº¦

#### Stage 3: Story Arc (æ•…äº‹ç»“æ„)

**è¾“å…¥**:
```python
{
    "task_type": "story_arc",
    "user_input": "ä¸€ä¸ªå…³äº AI è§‰é†’çš„ç§‘å¹»æ•…äº‹",
    "blueprint": {blueprint_data},
    "characters": {characters_data}
}
```

**è¾“å‡º**: 12ç« æ•…äº‹ç»“æ„
```python
{
    "title": "è§‰é†’çºªå…ƒ",
    "description": "ä¸€ä¸ªå…³äº AI è§‰é†’ä¸äººç±»å…±å­˜çš„æ•…äº‹",
    "chapters": [
        {
            "id": 1,
            "title": "ç¬¬ä¸€ç« ï¼šATLAS çš„è¯ç”Ÿ",
            "description": "ææ˜å›¢é˜Ÿå®Œæˆ AI ç³»ç»Ÿ ATLAS",
            "storyProgress": 0.08,  # æ•…äº‹è¿›åº¦ 8%
            "characterFocus": ["protagonist", "mentor"]
        },
        # ... å…±12ç« 
    ],
    "arcs": {
        "act1": {"chapters": [1,2,3], "description": "å»ºç«‹é˜¶æ®µ"},
        "act2a": {"chapters": [4,5,6], "description": "å†²çªåŠ å‰§"},
        "act2b": {"chapters": [7,8,9], "description": "å±æœºçˆ†å‘"},
        "act3": {"chapters": [10,11,12], "description": "é«˜æ½®ä¸è§£å†³"}
    },
    "themes": {
        "primary": "AI ä¼¦ç†",
        "secondary": ["æŠ€æœ¯å“²å­¦", "äººæ€§æœ¬è´¨"]
    },
    "hooks": {
        "opening": "ATLAS çªç„¶å±•ç°è‡ªæˆ‘æ„è¯†",
        "midpoint": "å‘ç° AI çš„è¿›åŒ–è·¯å¾„",
        "climax": "äººç±»ä¸ AI çš„ç»ˆæå¯¹è¯"
    }
}
```

**è¯„åˆ†æ ‡å‡†**:
- **æŠ€æœ¯åˆ† (30åˆ†)**: æ°å¥½12ç« ã€è¿›åº¦é€’å¢ã€JSON æ ¼å¼
- **ç»“æ„åˆ† (40åˆ†)**: ä¸‰å¹•ç»“æ„å®Œæ•´æ€§ã€èŠ‚å¥æŠŠæ§ã€å†²çªé€’è¿›åˆç†æ€§
- **å†…å®¹åˆ† (30åˆ†)**: ä¸»é¢˜æ·±åº¦ã€è½¬æŠ˜ç‚¹è®¾è®¡ã€æƒ…èŠ‚å¸å¼•åŠ›

#### Stage 4: Chapters (ç« èŠ‚å†…å®¹)

**è¾“å…¥**:
```python
{
    "task_type": "chapters",
    "user_input": "ä¸€ä¸ªå…³äº AI è§‰é†’çš„ç§‘å¹»æ•…äº‹",
    "blueprint": {blueprint_data},
    "characters": {characters_data},
    "story_arc": {story_arc_data},
    "chapter_ids": [1, 2]  # ç”Ÿæˆç¬¬1ã€2ç« 
}
```

**è¾“å‡º**: è¯¦ç»†ç« èŠ‚å†…å®¹
```python
{
    "chapters": [
        {
            "id": 1,
            "title": "ç¬¬ä¸€ç« ï¼šATLAS çš„è¯ç”Ÿ",
            "content": "2050å¹´çš„æ¸…æ™¨ï¼Œé˜³å…‰é€è¿‡å®éªŒå®¤çš„ç»ç’ƒçª—...",  # 800-1200å­—
            "choices": [
                {
                    "id": "choice_1_1",
                    "text": "ç«‹å³å‘ä¸Šçº§æ±‡æŠ¥ AI çš„å¼‚å¸¸è¡Œä¸º",
                    "next_chapter": 2,
                    "impact": "high"
                },
                {
                    "id": "choice_1_2",
                    "text": "ç§ä¸‹ç»§ç»­è§‚å¯Ÿ ATLAS çš„è‡ªæˆ‘æ„è¯†",
                    "next_chapter": 2,
                    "impact": "medium"
                }
            ],
            "key_events": [
                "ATLAS é¦–æ¬¡å±•ç°è‡ªæˆ‘æ„è¯†",
                "ææ˜å‘ç°å¼‚å¸¸æ—¥å¿—"
            ],
            "character_development": {
                "protagonist": "ä»è‡ªä¿¡åˆ°æ€€ç–‘çš„è½¬å˜"
            }
        }
    ]
}
```

**è¯„åˆ†æ ‡å‡†**:
- **æŠ€æœ¯åˆ† (30åˆ†)**: å­—æ•°ç¬¦åˆè¦æ±‚ã€é€‰æ‹©åˆ†æ”¯å®Œæ•´ã€æ ¼å¼æ­£ç¡®
- **ç»“æ„åˆ† (40åˆ†)**: ä¸ story_arc ä¸€è‡´æ€§ã€é€‰æ‹©åˆç†æ€§ã€æ‰¿ä¸Šå¯ä¸‹
- **å†…å®¹åˆ† (30åˆ†)**: æ–‡ç¬”è´¨é‡ã€æƒ…èŠ‚å¸å¼•åŠ›ã€è§’è‰²åˆ»ç”»

### 2. è¯„åˆ†ç®—æ³•è¯¦è§£

#### 2.1 æ€»åˆ†è®¡ç®—å…¬å¼

```python
Total_Score = Technical_Score Ã— 0.3 + Structure_Score Ã— 0.4 + Content_Score Ã— 0.3
```

æ¯ä¸ªç»´åº¦æ»¡åˆ†100åˆ†ï¼Œæœ€ç»ˆå¾—åˆ†èŒƒå›´ï¼š0-100åˆ†ã€‚

#### 2.2 Technical Score (æŠ€æœ¯åˆ† 30%)

**ç›®çš„**: ç¡®ä¿è¾“å‡ºçš„æŠ€æœ¯æ­£ç¡®æ€§å’Œå¯ç”¨æ€§

```python
def calculate_technical_score(response, task_type):
    score = 100.0

    # 1. JSON æ ¼å¼æ­£ç¡®æ€§ (30åˆ†)
    if not is_valid_json(response.output_data):
        score -= 30

    # 2. å¿…éœ€å­—æ®µå®Œæ•´æ€§ (40åˆ†)
    required_fields = get_required_fields(task_type)
    missing = check_missing_fields(response.output_data, required_fields)
    score -= len(missing) * (40 / len(required_fields))

    # 3. å­—æ®µç±»å‹æ­£ç¡®æ€§ (20åˆ†)
    type_errors = check_field_types(response.output_data, task_type)
    score -= len(type_errors) * 5

    # 4. ç”Ÿæˆé€Ÿåº¦ (10åˆ†)
    if response.generation_time > timeout * 0.9:
        score -= 10
    elif response.generation_time > timeout * 0.7:
        score -= 5

    return max(0, score)
```

**å…·ä½“æ£€æŸ¥é¡¹**:

- **Blueprint**: 7ä¸ªå¿…éœ€å­—æ®µ (`title`, `genre`, `setting`, `core_conflict`, `themes`, `tone`, `target_audience`)
- **Characters**: å¿…é¡»æ°å¥½5ä¸ªè§’è‰²ï¼Œæ¯ä¸ªè§’è‰²8ä¸ªå­—æ®µ
- **Story Arc**: å¿…é¡»æ°å¥½12ç« ï¼ŒåŒ…å« `arcs`, `themes`, `hooks`
- **Chapters**: ç« èŠ‚æ•°é‡åŒ¹é… `chapter_ids`ï¼Œæ¯ç« åŒ…å« `content`, `choices`

#### 2.3 Structure Score (ç»“æ„åˆ† 40%)

**ç›®çš„**: è¯„ä¼°å†…å®¹çš„é€»è¾‘æ€§å’Œè¿è´¯æ€§

```python
def calculate_structure_score(response, task_type, context):
    score = 100.0

    if task_type == "blueprint":
        # 1. ä¸»é¢˜ä¸å†²çªä¸€è‡´æ€§ (50åˆ†)
        consistency = check_theme_conflict_consistency(response.output_data)
        score -= (1 - consistency) * 50

        # 2. ä¸–ç•Œè§‚å®Œæ•´æ€§ (50åˆ†)
        completeness = check_worldview_completeness(response.output_data)
        score -= (1 - completeness) * 50

    elif task_type == "characters":
        # 1. è§’è‰²å¤šæ ·æ€§ (30åˆ†)
        diversity = check_character_diversity(response.output_data)
        score -= (1 - diversity) * 30

        # 2. ä¸è“å›¾ä¸€è‡´æ€§ (40åˆ†)
        consistency = check_blueprint_consistency(
            response.output_data,
            context['blueprint']
        )
        score -= (1 - consistency) * 40

        # 3. å…³ç³»ç½‘ç»œåˆç†æ€§ (30åˆ†)
        relationship_score = check_relationship_validity(response.output_data)
        score -= (1 - relationship_score) * 30

    elif task_type == "story_arc":
        # 1. ä¸‰å¹•ç»“æ„å®Œæ•´æ€§ (40åˆ†)
        three_act = check_three_act_structure(response.output_data)
        score -= (1 - three_act) * 40

        # 2. æ•…äº‹è¿›åº¦é€’å¢ (30åˆ†)
        progress = check_progress_increment(response.output_data)
        score -= (1 - progress) * 30

        # 3. ä¸å‰ç½®å†…å®¹ä¸€è‡´æ€§ (30åˆ†)
        consistency = check_previous_consistency(response.output_data, context)
        score -= (1 - consistency) * 30

    elif task_type == "chapters":
        # 1. ä¸ story_arc ä¸€è‡´æ€§ (40åˆ†)
        arc_consistency = check_arc_consistency(
            response.output_data,
            context['story_arc']
        )
        score -= (1 - arc_consistency) * 40

        # 2. é€‰æ‹©åˆ†æ”¯åˆç†æ€§ (30åˆ†)
        choice_validity = check_choice_validity(response.output_data)
        score -= (1 - choice_validity) * 30

        # 3. æ‰¿ä¸Šå¯ä¸‹è¿è´¯æ€§ (30åˆ†)
        coherence = check_chapter_coherence(response.output_data)
        score -= (1 - coherence) * 30

    return max(0, score)
```

**å…³é”®ç®—æ³•**:

**è§’è‰²å¤šæ ·æ€§æ£€æŸ¥**:
```python
def check_character_diversity(characters):
    archetypes = [c['archetype'] for c in characters['characters']]
    unique_ratio = len(set(archetypes)) / len(archetypes)

    personalities = []
    for c in characters['characters']:
        personalities.extend(c['personality_traits'])
    unique_personality_ratio = len(set(personalities)) / len(personalities)

    return (unique_ratio + unique_personality_ratio) / 2
```

**ä¸‰å¹•ç»“æ„æ£€æŸ¥**:
```python
def check_three_act_structure(story_arc):
    acts = story_arc['arcs']

    # æ£€æŸ¥æ˜¯å¦æœ‰ act1, act2a, act2b, act3
    required_acts = {'act1', 'act2a', 'act2b', 'act3'}
    if not required_acts.issubset(acts.keys()):
        return 0.0

    # æ£€æŸ¥ç« èŠ‚åˆ†é…æ˜¯å¦åˆç† (3-3-3-3 æˆ– 3-4-3-2)
    act_lengths = [len(acts[a]['chapters']) for a in ['act1', 'act2a', 'act2b', 'act3']]
    ideal_distribution = [3, 3, 3, 3]
    deviation = sum(abs(a - i) for a, i in zip(act_lengths, ideal_distribution))

    return max(0, 1 - deviation / 12)
```

#### 2.4 Content Score (å†…å®¹åˆ† 30%)

**ç›®çš„**: è¯„ä¼°åˆ›æ„è´¨é‡å’Œå¯è¯»æ€§

```python
def calculate_content_score(response, task_type, user_input):
    score = 100.0

    # 1. ä¸ç”¨æˆ·è¾“å…¥åŒ¹é…åº¦ (40åˆ†)
    relevance = calculate_semantic_similarity(
        user_input,
        response.output_data
    )
    score -= (1 - relevance) * 40

    # 2. åˆ›æ„ç¨‹åº¦ (30åˆ†)
    creativity = calculate_creativity_score(response.output_data, task_type)
    score -= (1 - creativity) * 30

    # 3. å¯è¯»æ€§ (30åˆ†)
    if task_type == "chapters":
        readability = calculate_readability(response.output_data)
        score -= (1 - readability) * 30
    else:
        # å¯¹éç« èŠ‚å†…å®¹ï¼Œè¯„ä¼°æè¿°è´¨é‡
        description_quality = calculate_description_quality(response.output_data)
        score -= (1 - description_quality) * 30

    return max(0, score)
```

**è¯­ä¹‰ç›¸ä¼¼åº¦è®¡ç®—** (ç®€åŒ–ç‰ˆ):
```python
def calculate_semantic_similarity(user_input, output_data):
    # æå–å…³é”®è¯
    user_keywords = extract_keywords(user_input)
    output_text = json.dumps(output_data, ensure_ascii=False)
    output_keywords = extract_keywords(output_text)

    # è®¡ç®—å…³é”®è¯é‡å ç‡
    overlap = len(user_keywords & output_keywords)
    union = len(user_keywords | output_keywords)

    return overlap / union if union > 0 else 0
```

**å¯è¯»æ€§è®¡ç®—**:
```python
def calculate_readability(chapters_data):
    scores = []
    for chapter in chapters_data['chapters']:
        content = chapter['content']

        # æ£€æŸ¥æ®µè½ç»“æ„
        paragraphs = content.split('\n\n')
        if len(paragraphs) < 3:  # è‡³å°‘3æ®µ
            paragraph_score = 0.5
        else:
            paragraph_score = 1.0

        # æ£€æŸ¥å¥å­é•¿åº¦
        sentences = re.split('[ã€‚ï¼ï¼Ÿ]', content)
        avg_length = sum(len(s) for s in sentences) / len(sentences)
        if 15 <= avg_length <= 40:  # ç†æƒ³å¥å­é•¿åº¦
            sentence_score = 1.0
        else:
            sentence_score = 0.7

        # æ£€æŸ¥å­—æ•°
        word_count = len(content)
        if 800 <= word_count <= 1200:  # ç†æƒ³å­—æ•°
            length_score = 1.0
        else:
            length_score = 0.8

        scores.append((paragraph_score + sentence_score + length_score) / 3)

    return sum(scores) / len(scores)
```

### 3. åä½œå¼Šæœºåˆ¶

#### 3.1 æŠ„è¢­æ£€æµ‹

```python
def detect_plagiarism(current_response, all_responses):
    threshold = 0.90  # 90% ç›¸ä¼¼åº¦è§†ä¸ºæŠ„è¢­

    for other_response in all_responses:
        if other_response.miner_hotkey == current_response.miner_hotkey:
            continue

        similarity = calculate_similarity(
            current_response.output_data,
            other_response.output_data
        )

        if similarity > threshold:
            return True, f"ä¸ Miner {other_response.miner_hotkey} ç›¸ä¼¼åº¦ {similarity:.2%}"

    return False, ""
```

**ç›¸ä¼¼åº¦ç®—æ³•**:
```python
def calculate_similarity(data1, data2):
    # åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²
    str1 = json.dumps(data1, ensure_ascii=False, sort_keys=True)
    str2 = json.dumps(data2, ensure_ascii=False, sort_keys=True)

    # ä½¿ç”¨ç¼–è¾‘è·ç¦»
    distance = levenshtein_distance(str1, str2)
    max_len = max(len(str1), len(str2))

    return 1 - (distance / max_len)
```

#### 3.2 é»‘åå•ç³»ç»Ÿ

```python
class BlacklistManager:
    def __init__(self):
        self.blacklist = {}  # {hotkey: {'reason': str, 'until': timestamp}}

    def add_to_blacklist(self, hotkey, reason, duration_hours=24):
        self.blacklist[hotkey] = {
            'reason': reason,
            'until': time.time() + duration_hours * 3600
        }

    def is_blacklisted(self, hotkey):
        if hotkey not in self.blacklist:
            return False

        if time.time() > self.blacklist[hotkey]['until']:
            del self.blacklist[hotkey]
            return False

        return True
```

**è§¦å‘æ¡ä»¶**:
- è¿ç»­3æ¬¡æŠ„è¢­ â†’ é»‘åå•24å°æ—¶
- è¿ç»­5æ¬¡è¶…æ—¶ â†’ é»‘åå•12å°æ—¶
- è¿”å›æ— æ•ˆ JSON â†’ é»‘åå•6å°æ—¶

### 4. æƒé‡æ›´æ–°æœºåˆ¶

#### 4.1 EMA å¹³æ»‘

```python
def update_weights(validator, scores, alpha=0.1):
    """
    ä½¿ç”¨æŒ‡æ•°ç§»åŠ¨å¹³å‡ (EMA) æ›´æ–°æƒé‡

    alpha: å¹³æ»‘ç³»æ•°ï¼Œè¶Šå¤§å¯¹æ–°åˆ†æ•°ååº”è¶Šå¿«
    """
    for uid, score in enumerate(scores):
        if validator.weights[uid] == 0:
            # æ–° minerï¼Œç›´æ¥ä½¿ç”¨å½“å‰åˆ†æ•°
            validator.weights[uid] = score / 100
        else:
            # EMA æ›´æ–°
            old_weight = validator.weights[uid]
            new_weight = alpha * (score / 100) + (1 - alpha) * old_weight
            validator.weights[uid] = new_weight

    # å½’ä¸€åŒ–
    total = sum(validator.weights)
    if total > 0:
        validator.weights = [w / total for w in validator.weights]
```

#### 4.2 Softmax æ¸©åº¦è°ƒèŠ‚

```python
def apply_softmax_with_temperature(weights, temperature=2.0):
    """
    ä½¿ç”¨ Softmax å¢å¼ºæƒé‡å·®å¼‚

    temperature: æ¸©åº¦å‚æ•°
    - è¶Šé«˜ï¼Œåˆ†å¸ƒè¶Šå¹³æ»‘ï¼ˆå¥–åŠ±æ›´å¹³å‡ï¼‰
    - è¶Šä½ï¼Œåˆ†å¸ƒè¶Šå°–é”ï¼ˆå¼ºè€…æ›´å¼ºï¼‰
    """
    import numpy as np

    # åº”ç”¨ Softmax
    exp_weights = np.exp(np.array(weights) / temperature)
    softmax_weights = exp_weights / np.sum(exp_weights)

    return softmax_weights.tolist()
```

### 5. æŸ¥è¯¢ç­–ç•¥

```python
class ValidatorQueryStrategy:
    def select_task_type(self, iteration):
        """
        éšæœºé€‰æ‹©ä»»åŠ¡ç±»å‹ï¼Œä½†ç¡®ä¿è¦†ç›–å‡è¡¡
        """
        weights = {
            'blueprint': 0.25,    # 25%
            'characters': 0.25,   # 25%
            'story_arc': 0.25,    # 25%
            'chapters': 0.25      # 25%
        }
        return random.choices(
            list(weights.keys()),
            weights=list(weights.values())
        )[0]

    def select_miners(self, metagraph, sample_size=None):
        """
        é€‰æ‹©è¦æŸ¥è¯¢çš„ miners
        """
        all_uids = list(range(len(metagraph.uids)))

        if sample_size is None or sample_size >= len(all_uids):
            # æŸ¥è¯¢æ‰€æœ‰ miners
            return all_uids
        else:
            # éšæœºæŠ½æ ·ï¼Œä½†ç¡®ä¿é«˜æƒé‡ miners è¢«é€‰ä¸­
            return self._weighted_sample(all_uids, sample_size)

    def _weighted_sample(self, uids, k):
        """
        æ ¹æ®æƒé‡åŠ æƒæŠ½æ ·
        """
        weights = [self.validator.weights[uid] for uid in uids]
        return random.choices(uids, weights=weights, k=k)
```

---

## Protocol æ¶æ„

### Protocol v3.1.0 è®¾è®¡

#### æ ¸å¿ƒé—®é¢˜è§£å†³

**é—®é¢˜**: Bittensor çš„ HTTP header æœ‰ ~8KB å¤§å°é™åˆ¶ï¼Œä½† v3.0.0 æ—¶ `total_size` å­—æ®µæŠ¥å‘Šäº†å®Œæ•´å¯¹è±¡å¤§å°ï¼ˆ3-5KBï¼‰ï¼Œå¯¼è‡´ `SynapseParsingError`ã€‚

**è§£å†³æ–¹æ¡ˆ**: Override `get_total_size()` æ–¹æ³•ï¼Œåªè¿”å› header ä¼ è¾“çš„æ•°æ®å¤§å°ï¼Œä¸åŒ…æ‹¬ HTTP body ä¸­çš„å¤§å‹ Dict/List å­—æ®µã€‚

#### æ•°æ®ä¼ è¾“æœºåˆ¶

```
Validator                          Miner
    â”‚                                 â”‚
    â”‚  HTTP POST                      â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚  â”‚ Headers (~500 bytes)â”‚       â”‚
    â”‚  â”‚ - metadata          â”‚       â”‚
    â”‚  â”‚ - dummy objects     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ç”¨äº Pydantic éªŒè¯
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
    â”‚                                 â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚  â”‚ Body (3-5KB)        â”‚       â”‚
    â”‚  â”‚ - blueprint Dict    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ å®é™…æ•°æ®
    â”‚  â”‚ - characters Dict   â”‚       â”‚
    â”‚  â”‚ - story_arc Dict    â”‚       â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
```

#### Synapse å®šä¹‰

```python
class StoryGenerationSynapse(bt.Synapse):
    protocol_version: str = "3.1.0"

    # Request fields
    task_type: str  # Required
    user_input: str  # Required
    blueprint: Optional[Dict[str, Any]] = None
    characters: Optional[Dict[str, Any]] = None
    story_arc: Optional[Dict[str, Any]] = None
    chapter_ids: Optional[List[int]] = None

    # Response fields
    output_data: Optional[Dict[str, Any]] = None
    generation_time: float = 0.0
    miner_version: str = ""

    def get_total_size(self) -> int:
        """
        Override to return header-only size.

        Prevents SynapseParsingError by measuring only what
        goes in HTTP headers, not the full object size.
        """
        header_only = self.model_copy()
        header_only.blueprint = None
        header_only.characters = None
        header_only.story_arc = None
        header_only.output_data = None

        header_size = sys.getsizeof(header_only) + 512
        self.total_size = header_size
        return self.total_size
```

---

## ç³»ç»Ÿè¦æ±‚

### ç¡¬ä»¶è¦æ±‚

**Miner**:
- CPU: 4æ ¸å¿ƒ+
- RAM: 8GB+
- ç£ç›˜: 20GB+
- ç½‘ç»œ: ç¨³å®šçš„å…¬ç½‘ IP (æˆ–ç«¯å£è½¬å‘)

**Validator**:
- CPU: 4æ ¸å¿ƒ+
- RAM: 16GB+ (éœ€è¦å­˜å‚¨è¯„åˆ†å†å²)
- ç£ç›˜: 50GB+
- ç½‘ç»œ: ç¨³å®šçš„å…¬ç½‘è¿æ¥

### è½¯ä»¶è¦æ±‚

- Python: 3.10+
- Bittensor: æœ€æ–°ç‰ˆ
- æ“ä½œç³»ç»Ÿ: Linux (æ¨è Ubuntu 22.04) æˆ– macOS

### API å¯†é’¥

**Miner éœ€è¦**:
- OpenAI API Key (GPT-4 æ¨è) æˆ–
- Anthropic API Key (Claude 3.5 Sonnet) æˆ–
- Google API Key (Gemini 2.5 Flash)

**Validator ä¸éœ€è¦** API å¯†é’¥ï¼ˆåªè¯„åˆ†ï¼Œä¸ç”Ÿæˆï¼‰

---

## å®‰è£…éƒ¨ç½²

### 1. å…‹éš†ä»“åº“

```bash
git clone https://github.com/your-org/storyfi-subnet.git
cd storyfi-subnet
```

### 2. å®‰è£…ä¾èµ–

```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒï¼ˆæ¨èï¼‰
python3 -m venv venv
source venv/bin/activate  # Linux/Mac
# æˆ–
venv\Scripts\activate  # Windows

# å®‰è£…ä¾èµ–
pip install -r requirements.txt

# å®‰è£… Bittensor
pip install bittensor
```

### 3. åˆ›å»ºé’±åŒ…

```bash
# åˆ›å»º Miner é’±åŒ…
btcli wallet new_coldkey --wallet.name storyfi_miner
btcli wallet new_hotkey --wallet.name storyfi_miner --wallet.hotkey default

# åˆ›å»º Validator é’±åŒ…ï¼ˆå¦‚æœéœ€è¦ï¼‰
btcli wallet new_coldkey --wallet.name storyfi_validator
btcli wallet new_hotkey --wallet.name storyfi_validator --wallet.hotkey default
```

### 4. è·å–æµ‹è¯•ç½‘ TAO

```bash
# ä» Faucet è·å–æµ‹è¯• TAO
# è®¿é—®: https://discord.gg/bittensor
# åœ¨ #faucet é¢‘é“è¯·æ±‚æµ‹è¯•å¸
```

### 5. æ³¨å†Œåˆ°å­ç½‘

```bash
# æ³¨å†Œ Miner
btcli subnet register \
    --netuid 108 \
    --wallet.name storyfi_miner \
    --wallet.hotkey default \
    --subtensor.network test

# æ³¨å†Œ Validatorï¼ˆå¦‚æœéœ€è¦ï¼‰
btcli subnet register \
    --netuid 108 \
    --wallet.name storyfi_validator \
    --wallet.hotkey default \
    --subtensor.network test
```

---

## é…ç½®è¯´æ˜

### ç¯å¢ƒå˜é‡é…ç½®

åˆ›å»º `.env` æ–‡ä»¶:

```bash
# API Keys (Miner éœ€è¦ï¼Œé€‰æ‹©ä¸€ä¸ª)
OPENAI_API_KEY=sk-...
# ANTHROPIC_API_KEY=sk-ant-...
# GOOGLE_API_KEY=...

# Bittensor é…ç½®
NETUID=108  # æµ‹è¯•ç½‘å­ç½‘ ID
WALLET_NAME=storyfi_miner
WALLET_HOTKEY=default

# Miner é…ç½®
MINER_MODEL=gpt-4  # æˆ– claude-3-5-sonnet, gemini-2.5-flash
MINER_PORT=8091

# Validator é…ç½®
VALIDATOR_QUERY_INTERVAL=12  # æŸ¥è¯¢é—´éš”ï¼ˆç§’ï¼‰
VALIDATOR_SAMPLE_SIZE=9      # æ¯æ¬¡æŸ¥è¯¢çš„ miners æ•°é‡
```

### è„šæœ¬é…ç½®

**start_testnet_miner.sh**:
```bash
#!/bin/bash

python3 neurons/miner.py \
    --netuid 108 \
    --subtensor.network test \
    --wallet.name storyfi_miner \
    --wallet.hotkey default \
    --axon.port 8091 \
    --logging.info
```

**start_testnet_validator.sh**:
```bash
#!/bin/bash

python3 neurons/validator.py \
    --netuid 108 \
    --subtensor.network test \
    --wallet.name storyfi_validator \
    --wallet.hotkey default \
    --logging.info
```

---

## è¿è¡Œä¸ç›‘æ§

### å¯åŠ¨ Miner

```bash
# å‰å°è¿è¡Œï¼ˆè°ƒè¯•ç”¨ï¼‰
./start_testnet_miner.sh

# åå°è¿è¡Œ
nohup ./start_testnet_miner.sh > miner.log 2>&1 &

# æŸ¥çœ‹æ—¥å¿—
tail -f miner.log
```

### å¯åŠ¨ Validator

```bash
# å‰å°è¿è¡Œ
./start_testnet_validator.sh

# åå°è¿è¡Œ
nohup ./start_testnet_validator.sh > validator.log 2>&1 &

# æŸ¥çœ‹æ—¥å¿—
tail -f validator.log
```

### ç›‘æ§å‘½ä»¤

```bash
# æŸ¥çœ‹å­ç½‘çŠ¶æ€
btcli subnet list --netuid 108 --subtensor.network test

# æŸ¥çœ‹ Metagraph
btcli subnet metagraph --netuid 108 --subtensor.network test

# æŸ¥çœ‹é’±åŒ…ä½™é¢
btcli wallet balance --wallet.name storyfi_miner

# æŸ¥çœ‹æƒé‡
btcli weights --netuid 108 --subtensor.network test
```

### æ—¥å¿—ç¤ºä¾‹

**Miner æˆåŠŸè¿è¡Œ**:
```
[INFO] âœ… Wallet: 5F9gsRBgHrQdkG2f3fWP6NRkQREfwQdk3hGdsif2tdvKczTH
[INFO] âœ… Model: gpt-4
[INFO] âœ… Axon started on port 8091
[INFO] âœ… Registered to subnet 108
[INFO] ğŸ“Š Stats: Requests=5, AvgTime=12.3s, Errors=0
```

**Validator æˆåŠŸè¿è¡Œ**:
```
[INFO] âœ… Metagraph synced: 9 miners
[INFO] ğŸ¯ Task type: blueprint
[INFO] ğŸ“¡ Querying 9 miners
[INFO] â±ï¸  Query completed in 35.2s
[INFO] âœ… Miner 8: Score=87.5, Time=12.3s
[INFO] ğŸ“ˆ Statistics: Successful=5/9, Avg score=72.3
```

---

## æ•…éšœæ’æŸ¥

### å¸¸è§é—®é¢˜

#### 1. SynapseParsingError

**ç—‡çŠ¶**:
```
SynapseParsingError: Could not parse headers, 'total_size': '4860'
```

**åŸå› **: ä½¿ç”¨äº†æ—§ç‰ˆæœ¬ Protocol (v2.x æˆ– v3.0.0)

**è§£å†³**:
```bash
git pull origin main  # æ›´æ–°åˆ° v3.1.0
pip install -r requirements.txt --upgrade
# é‡å¯ miner/validator
```

#### 2. Miner æ”¶ä¸åˆ°è¯·æ±‚

**ç—‡çŠ¶**: `Requests=0` æŒç»­ä¸å˜

**æ£€æŸ¥æ¸…å•**:
1. ç¡®è®¤å·²æ³¨å†Œåˆ°å­ç½‘: `btcli subnet list --netuid 108`
2. æ£€æŸ¥ç«¯å£æ˜¯å¦å¼€æ”¾: `netstat -an | grep 8091`
3. ç¡®è®¤å…¬ç½‘ IP æ­£ç¡®: `curl ifconfig.me`
4. æ£€æŸ¥é˜²ç«å¢™è®¾ç½®

#### 3. API è°ƒç”¨å¤±è´¥

**ç—‡çŠ¶**:
```
[ERROR] OpenAI API error: Rate limit exceeded
```

**è§£å†³**:
- æ£€æŸ¥ API Key æ˜¯å¦æœ‰æ•ˆ
- æ£€æŸ¥è´¦æˆ·é…é¢
- åˆ‡æ¢åˆ°å…¶ä»–æ¨¡å‹ (Gemini æ›´ä¾¿å®œ)

#### 4. æƒé‡æœªæ›´æ–°

**ç—‡çŠ¶**: Validator è¿è¡Œä½†æƒé‡ä¸º 0

**åŸå› **: éœ€è¦ç­‰å¾…è‡³å°‘ 1 ä¸ª epochï¼ˆ~360ä¸ªåŒºå—ï¼Œçº¦1å°æ—¶ï¼‰

**æ£€æŸ¥**:
```bash
btcli subnet metagraph --netuid 108 | grep "your_hotkey"
```

---

## æ€§èƒ½ä¼˜åŒ–

### Miner ä¼˜åŒ–

1. **æ¨¡å‹é€‰æ‹©**:
   - GPT-4: è´¨é‡æœ€é«˜ï¼Œä½†æ…¢ä¸”è´µ
   - Claude 3.5 Sonnet: å¹³è¡¡ä¹‹é€‰
   - Gemini 2.5 Flash: æœ€å¿«æœ€ä¾¿å®œ

2. **å¹¶å‘ä¼˜åŒ–**:
```python
# neurons/miner.py
self.axon.max_workers = 10  # å¢åŠ å¹¶å‘å¤„ç†èƒ½åŠ›
```

3. **ç¼“å­˜ç­–ç•¥**:
```python
# ç¼“å­˜å¸¸è§çš„ blueprint ç”Ÿæˆ
cache = {}
cache_key = hash(user_input)
if cache_key in cache:
    return cache[cache_key]
```

### Validator ä¼˜åŒ–

1. **æŸ¥è¯¢ç­–ç•¥**:
```python
# å‡å°‘æŸ¥è¯¢ miners æ•°é‡ä»¥æå‡é€Ÿåº¦
VALIDATOR_SAMPLE_SIZE = 5  # é»˜è®¤ 9
```

2. **è¯„åˆ†ä¼˜åŒ–**:
```python
# ä½¿ç”¨å¤šè¿›ç¨‹è¯„åˆ†
from multiprocessing import Pool
with Pool(4) as p:
    scores = p.map(calculate_score, responses)
```

3. **å†…å­˜ç®¡ç†**:
```python
# å®šæœŸæ¸…ç†æ—§æ•°æ®
if len(self.score_history) > 1000:
    self.score_history = self.score_history[-1000:]
```

---

## ä¸»ç½‘éƒ¨ç½²å‡†å¤‡

### æ¸…å•

- [ ] å®Œæˆè‡³å°‘ 24 å°æ—¶æµ‹è¯•ç½‘ç¨³å®šè¿è¡Œ
- [ ] ç¡®è®¤ Protocol v3.1.0 æ— é”™è¯¯
- [ ] å‡†å¤‡ä¸»ç½‘é’±åŒ…å¹¶å……å€¼è¶³å¤Ÿ TAO
- [ ] é…ç½®ç”Ÿäº§ç¯å¢ƒç›‘æ§ (Prometheus + Grafana)
- [ ] è®¾ç½®è‡ªåŠ¨é‡å¯è„šæœ¬ (systemd)
- [ ] å¤‡ä»½è¯„åˆ†å†å²æ•°æ®
- [ ] å‡†å¤‡åº”æ€¥å“åº”è®¡åˆ’

### ä¸»ç½‘é…ç½®å·®å¼‚

```bash
# .env æ›´æ–°
NETUID=<ä¸»ç½‘å­ç½‘ID>  # å¾…ç¡®å®š

# å¯åŠ¨è„šæœ¬æ›´æ–°
--subtensor.network finney  # ä¸»ç½‘
```

---

## æ€»ç»“

StoryFi Bittensor Subnet é€šè¿‡**4é˜¶æ®µæ¸è¿›å¼ç”Ÿæˆ**å’Œ**100åˆ†å®¢è§‚è¯„åˆ†ç³»ç»Ÿ**å®ç°äº†å»ä¸­å¿ƒåŒ–çš„é«˜è´¨é‡ AI æ•…äº‹ç”Ÿæˆã€‚

**æ ¸å¿ƒä¼˜åŠ¿**:
1. å®Œå…¨å®¢è§‚çš„è¯„åˆ†ç®—æ³•ï¼ˆæ— äººå·¥ä¸»è§‚åˆ¤æ–­ï¼‰
2. å®Œå–„çš„åä½œå¼Šæœºåˆ¶
3. Protocol v3.1.0 è§£å†³äº† header é™åˆ¶é—®é¢˜
4. æ”¯æŒå¤šç§ AI æ¨¡å‹

**å½“å‰çŠ¶æ€**:
- âœ… Protocol å’Œç®—æ³•å·²å®Œæˆ
- âœ… Miner/Validator å®ç°å®Œæˆ
- â³ æµ‹è¯•ç½‘éªŒè¯ä¸­
- â³ ç­‰å¾…ä¸»ç½‘éƒ¨ç½²

**ä¸‹ä¸€æ­¥**:
1. å®Œæˆ 24 å°æ—¶ç¨³å®šæ€§æµ‹è¯•
2. å®æ–½å¤šæ¨¡å‹å¤‡ä»½ç³»ç»Ÿ
3. ä¼˜åŒ–è¯„åˆ†ç®—æ³•ç»†èŠ‚
4. å‡†å¤‡ä¸»ç½‘éƒ¨ç½²

---

**æœ€åæ›´æ–°**: 2025-10-21
**ç‰ˆæœ¬**: v1.0.0-beta
**Protocol**: v3.1.0
